# Generated by Django 5.2.8 on 2025-12-04 14:35

from django.db import migrations, models


TRIGGER_SQL = """
CREATE OR REPLACE FUNCTION atletas_validar_classe_elegivel()
RETURNS trigger AS $$
DECLARE
    v_ano_evento integer;
    v_ano_nasc integer;
    v_idade integer;
    v_classe_origem_id integer;
    v_permitido boolean;
BEGIN
    IF NEW.classe_real_id IS NULL THEN
        RAISE EXCEPTION 'classe_real_id é obrigatório para validar elegibilidade';
    END IF;

    SELECT EXTRACT(YEAR FROM c.data_competicao)::int
    INTO v_ano_evento
    FROM atletas_campeonato c
    WHERE c.id = NEW.campeonato_id;

    IF v_ano_evento IS NULL THEN
        RAISE EXCEPTION 'campeonato.data_competicao inválida para elegibilidade';
    END IF;

    SELECT COALESCE(EXTRACT(YEAR FROM a.data_nascimento)::int, a.ano_nasc)
    INTO v_ano_nasc
    FROM atletas_atleta a
    WHERE a.id = NEW.atleta_id;

    IF v_ano_nasc IS NULL THEN
        RAISE EXCEPTION 'atleta sem ano de nascimento para elegibilidade';
    END IF;

    v_idade := v_ano_evento - v_ano_nasc;

    SELECT cl.id
    INTO v_classe_origem_id
    FROM atletas_classe cl
    WHERE v_idade BETWEEN cl.idade_min AND cl.idade_max
    ORDER BY cl.idade_min
    LIMIT 1;

    IF v_classe_origem_id IS NULL THEN
        RAISE EXCEPTION 'classe de origem não encontrada para idade %', v_idade;
    END IF;

    SELECT EXISTS (
        SELECT 1
        FROM atletas_classeelegivel ce
        WHERE ce.classe_origem_id = v_classe_origem_id
          AND ce.classe_destino_id = NEW.classe_real_id
    )
    INTO v_permitido;

    IF NOT v_permitido THEN
        RAISE EXCEPTION 'classe destino % não elegível para classe base %',
            NEW.classe_real_id, v_classe_origem_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS atletas_validar_classe_elegivel_trg ON atletas_inscricao;
CREATE TRIGGER atletas_validar_classe_elegivel_trg
BEFORE INSERT OR UPDATE OF classe_real_id, atleta_id, campeonato_id
ON atletas_inscricao
FOR EACH ROW
EXECUTE FUNCTION atletas_validar_classe_elegivel();
"""

TRIGGER_SQL_REVERSE = """
DROP TRIGGER IF EXISTS atletas_validar_classe_elegivel_trg ON atletas_inscricao;
DROP FUNCTION IF EXISTS atletas_validar_classe_elegivel();
"""


def populate_classe_elegivel(apps, schema_editor):
    Classe = apps.get_model("atletas", "Classe")
    ClasseElegivel = apps.get_model("atletas", "ClasseElegivel")

    for classe in Classe.objects.all():
        ClasseElegivel.objects.get_or_create(
            classe_origem=classe,
            classe_destino=classe,
        )

    def add_mappings(orig_names, dest_names):
        orig_qs = Classe.objects.filter(nome__in=orig_names)
        dest_qs = Classe.objects.filter(nome__in=dest_names)
        for origem in orig_qs:
            for destino in dest_qs:
                ClasseElegivel.objects.get_or_create(
                    classe_origem=origem,
                    classe_destino=destino,
                )

    add_mappings(["SUB-18"], ["SUB-18", "SUB-21", "SÊNIOR"])
    add_mappings(["SUB-21"], ["SUB-21", "SÊNIOR"])
    add_mappings(
        ["VETERANO", "VETERANOS", "MASTER"],
        ["VETERANO", "VETERANOS", "MASTER", "SÊNIOR"],
    )


def reverse_populate_classe_elegivel(apps, schema_editor):
    ClasseElegivel = apps.get_model("atletas", "ClasseElegivel")
    ClasseElegivel.objects.all().delete()


def create_trigger_if_postgres(apps, schema_editor):
    if schema_editor.connection.vendor != "postgresql":
        return
    schema_editor.execute(TRIGGER_SQL)


def drop_trigger_if_postgres(apps, schema_editor):
    if schema_editor.connection.vendor != "postgresql":
        return
    schema_editor.execute(TRIGGER_SQL_REVERSE)


class Migration(migrations.Migration):

    dependencies = [
        ("atletas", "0013_swap_auth_user_fk"),
    ]

    operations = [
        migrations.CreateModel(
            name="ClasseElegivel",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "classe_origem",
                    models.ForeignKey(
                        on_delete=models.deletion.CASCADE,
                        related_name="elegiveis_origem",
                        to="atletas.classe",
                        verbose_name="Classe de Origem",
                    ),
                ),
                (
                    "classe_destino",
                    models.ForeignKey(
                        on_delete=models.deletion.CASCADE,
                        related_name="elegiveis_destino",
                        to="atletas.classe",
                        verbose_name="Classe de Destino",
                    ),
                ),
            ],
            options={
                "verbose_name": "Classe Elegível",
                "verbose_name_plural": "Classes Elegíveis",
                "unique_together": {("classe_origem", "classe_destino")},
            },
        ),
        migrations.RunPython(
            populate_classe_elegivel,
            reverse_populate_classe_elegivel,
        ),
        migrations.RunPython(
            create_trigger_if_postgres,
            drop_trigger_if_postgres,
        ),
    ]
